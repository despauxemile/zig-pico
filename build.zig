const std = @import("std");

const CMAKE_BLD_DIR = "./build";
const PROJECT_NAME = "zig-pico";

pub fn build(b: *std.Build) anyerror!void {
    const target_query = std.Target.Query{
        .abi = .eabi,
        .cpu_arch = .thumb,
        .cpu_model = .{ .explicit = &std.Target.arm.cpu.cortex_m0plus },
        .os_tag = .freestanding,
    };
    const target = b.resolveTargetQuery(target_query);

    const optimize = b.standardOptimizeOption(.{});

    const lib = b.addStaticLibrary(.{
        .name = "zig-main",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    // RP2040 setup -- removes #include for useless file for the 2040
    lib.addIncludePath(b.path("include"));

    // link arm-none-eabi-newlib (on arch linux /usr/arm-none-eabi/)
    const arm_lib_path = "/usr/arm-none-eabi/include";
    std.fs.accessAbsolute(arm_lib_path, .{}) catch {
        std.log.err("no arm header dir found at {s}", .{arm_lib_path});
        return;
    };
    lib.addSystemIncludePath(.{ .cwd_relative = arm_lib_path });

    // generated by cmake, building `lib` must depend on `cmake_gen` step...
    lib.addSystemIncludePath(b.path("build/generated/pico_base"));

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const alloc = gpa.allocator();

    // add sdk headers
    const sdk_path = std.process.getEnvVarOwned(alloc, "PICO_SDK_PATH") catch {
        std.log.err("variable PICO_SDK_PATH not defined", .{});
        return;
    };
    defer alloc.free(sdk_path);

    const sdk_src_path = try std.fmt.allocPrint(alloc, "{s}/src", .{sdk_path});
    defer alloc.free(sdk_src_path);

    var dir_iter = try std.fs.cwd().openDir(sdk_path, .{ .iterate = true });
    defer dir_iter.close();

    var walker = try dir_iter.walk(alloc);
    defer walker.deinit();

    const inc_paths = [_][]const u8{ "rp2040", "rp2_common", "common" };

    while (try walker.next()) |entry| {
        if (entry.kind == .directory and std.mem.eql(u8, entry.basename, "include")) {
            for (inc_paths) |p| {
                if (std.mem.containsAtLeast(u8, entry.path, 1, p)) {
                    // std.debug.print("entry: {s}, kind: {s}\n", .{ entry.path, @tagName(entry.kind) });
                    const real_path = try std.fmt.allocPrint(alloc, "{s}/{s}", .{ sdk_path, entry.path });
                    defer alloc.free(real_path);
                    // std.debug.print("entry: {s}\n", .{real_path});

                    lib.addIncludePath(.{ .cwd_relative = real_path });
                }
            }
        }
    }

    b.installArtifact(lib);

    // generate cmake project, needed by lib linking step
    const cmake_gen = b.addSystemCommand(&.{"cmake"});
    cmake_gen.addArgs(&.{ "-B", CMAKE_BLD_DIR });
    cmake_gen.setName("cmake: generate");

    // for generated headers
    lib.step.dependOn(&cmake_gen.step);

    // make the project
    const cmake_bld = b.addSystemCommand(&.{"cmake"});
    cmake_bld.addArgs(&.{ "--build", CMAKE_BLD_DIR, "--parallel" });
    cmake_bld.setName("cmake: build");
    cmake_bld.step.dependOn(b.getInstallStep());

    // copy output to zig-out
    const uf2_path = try std.fmt.allocPrint(alloc, "{s}/{s}.uf2", .{ CMAKE_BLD_DIR, PROJECT_NAME });
    defer alloc.free(uf2_path);

    const uf2_cp = b.addInstallFile(b.path(uf2_path), "zig-pico.uf2");
    uf2_cp.step.dependOn(&cmake_bld.step);

    b.default_step = &uf2_cp.step;
}
